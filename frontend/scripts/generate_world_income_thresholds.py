#!/usr/bin/env python3
"""
Generate world income threshold data from WID bulk download files.

Output:
  src/data/worldIncomeThresholds.ts
"""

from __future__ import annotations

import csv
import hashlib
import io
import re
import urllib.request
from datetime import date
from pathlib import Path
from typing import Dict, List, Tuple

ROOT = Path(__file__).resolve().parents[1]
OUT_PATH = ROOT / "src/data/worldIncomeThresholds.ts"

EXTRACTOR_VERSION = "wid-income-thresholds-v1"
YEAR = "2024"
VARIABLE = "tptincj992"
PERCENTILE_PATTERN = re.compile(r"^p([0-9]+(?:\.[0-9]+)?)p100$")

SOURCE_URL_BY_BASIS = {
    "PPP": "https://wid.world/bulk_download/WID_data_WO-PPP.csv",
    "MER": "https://wid.world/bulk_download/WID_data_WO-MER.csv",
}

COUNTRY_CODE_BY_BASIS = {
    "PPP": "WO-PPP",
    "MER": "WO-MER",
}


def format_number(value: float) -> str:
    if float(value).is_integer():
        return str(int(value))
    text = f"{value:.6f}".rstrip("0").rstrip(".")
    return text if text else "0"


def format_ts_string_or_null(value: str | None) -> str:
    if value is None:
        return "null"
    escaped = value.replace("\\", "\\\\").replace("'", "\\'")
    return f"'{escaped}'"


def fetch_csv(url: str) -> Tuple[bytes, str | None]:
    req = urllib.request.Request(url, headers={"User-Agent": "awesomerank-threshold-generator/1.0"})
    with urllib.request.urlopen(req, timeout=120) as response:
        raw = response.read()
        last_modified = response.headers.get("Last-Modified")
    return raw, last_modified


def parse_thresholds(raw_csv: bytes, country_code: str) -> List[Tuple[float, float]]:
    text = raw_csv.decode("utf-8", errors="ignore")
    reader = csv.DictReader(io.StringIO(text), delimiter=";")
    points: Dict[float, float] = {}

    for row in reader:
        if row.get("country") != country_code:
            continue
        if row.get("variable") != VARIABLE:
            continue
        if row.get("year") != YEAR:
            continue

        percentile = row.get("percentile", "")
        match = PERCENTILE_PATTERN.match(percentile)
        if not match:
            continue

        try:
            p = float(match.group(1))
            income = float(row.get("value", ""))
        except (TypeError, ValueError):
            continue

        points[p] = income

    if not points:
        raise RuntimeError(f"No thresholds found for {country_code} / {VARIABLE} / {YEAR}")

    return sorted(points.items(), key=lambda x: x[0])


def format_points(points: List[Tuple[float, float]]) -> str:
    lines = []
    for p, income in points:
        lines.append(f"    {{ p: {format_number(p)}, income: {format_number(income)} }},")
    return "\n".join(lines)


def main() -> None:
    thresholds_by_basis: Dict[str, List[Tuple[float, float]]] = {}
    source_last_modified: Dict[str, str | None] = {}
    source_hash: Dict[str, str] = {}

    for basis, url in SOURCE_URL_BY_BASIS.items():
        raw_csv, last_modified = fetch_csv(url)
        thresholds_by_basis[basis] = parse_thresholds(raw_csv, COUNTRY_CODE_BY_BASIS[basis])
        source_last_modified[basis] = last_modified
        source_hash[basis] = hashlib.sha256(raw_csv).hexdigest()

    out = f"""// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by scripts/generate_world_income_thresholds.py

export type IncomeBasis = 'PPP' | 'MER';

export type IncomeThresholdPoint = Readonly<{{
  /** Percentile (0â€“100). Example: 99.9 => threshold for top 0.1%. */
  p: number;
  /** Annual income threshold in USD (PPP-adjusted or market exchange rate depending on basis). */
  income: number;
}}>;

/**
 * World income thresholds derived from WID.world bulk download files.
 * Variable: {VARIABLE} (Threshold, pre-tax national income; equal-split adults; age 20+).
 * Year: {YEAR}
 */
export const WORLD_INCOME_WID = {{
  year: {YEAR} as const,
  variable: '{VARIABLE}',
  generatedAt: '{date.today().isoformat()}',
  extractorVersion: '{EXTRACTOR_VERSION}',
  countryCodeByBasis: {{
    PPP: 'WO-PPP',
    MER: 'WO-MER',
  }} as const satisfies Record<IncomeBasis, string>,
  sourceFileByBasis: {{
    PPP: '{SOURCE_URL_BY_BASIS["PPP"]}',
    MER: '{SOURCE_URL_BY_BASIS["MER"]}',
  }} as const satisfies Record<IncomeBasis, string>,
  sourceLastModified: {{
    PPP: {format_ts_string_or_null(source_last_modified["PPP"])},
    MER: {format_ts_string_or_null(source_last_modified["MER"])},
  }} as const satisfies Record<IncomeBasis, string | null>,
  sourceHash: {{
    PPP: '{source_hash["PPP"]}',
    MER: '{source_hash["MER"]}',
  }} as const satisfies Record<IncomeBasis, string>,
}} as const;

export const WORLD_INCOME_THRESHOLDS_USD: Record<IncomeBasis, ReadonlyArray<IncomeThresholdPoint>> = {{
  PPP: [
{format_points(thresholds_by_basis["PPP"])}
  ],
  MER: [
{format_points(thresholds_by_basis["MER"])}
  ],
}};
"""

    OUT_PATH.write_text(out)
    print(f"Wrote {OUT_PATH}")


if __name__ == "__main__":
    main()
